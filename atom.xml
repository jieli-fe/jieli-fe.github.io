<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端博客</title>
  
  <subtitle>大王叫我来做前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.h5per.com/"/>
  <updated>2019-11-21T02:33:59.286Z</updated>
  <id>http://www.h5per.com/</id>
  
  <author>
    <name>JIE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端缓存机制</title>
    <link href="http://www.h5per.com/2019/11/21/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.h5per.com/2019/11/21/前端缓存机制/</id>
    <published>2019-11-21T02:25:03.000Z</published>
    <updated>2019-11-21T02:33:59.286Z</updated>
    
    <content type="html"><![CDATA[<p>作者： <a href="https://staven630.github.io/blog/" target="_blank" rel="noopener">https://staven630.github.io/blog/</a></p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>&emsp;&emsp;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p><p>&emsp;&emsp;所有缓存资源都仅仅针对GET请求，而对POST，DELETE，PUT这类行为操作通常不做任何缓存。</p><h1 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h1><ul><li>减小网络I/O,减小服务器压力</li><li>加快页面访问速度</li><li>减少宽带消耗<a id="more"></a><h1 id="浏览器静态资源请求流程"><a href="#浏览器静态资源请求流程" class="headerlink" title="浏览器静态资源请求流程"></a>浏览器静态资源请求流程</h1><img src="/imgs/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f32352f63393134383063383130336161613339666537643030306363386633616135393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d657.webp" alt="浏览器静态资源请求流程"></li></ul><h1 id="资源缓存分类"><a href="#资源缓存分类" class="headerlink" title="资源缓存分类"></a>资源缓存分类</h1><p>&emsp;&emsp;按照获取资源时请求的优先级依次排序：</p><ul><li>Memory Cache、Disk Cache</li><li>Service Worker Cache</li><li>HTTP Cache</li><li>Push Cache</li></ul><h1 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP-Cache"></a>HTTP-Cache</h1><p>&emsp;&emsp;HTTP缓存又分为强缓存与协商缓存。强缓存优先级高于协商缓存。在匹配强缓存失败后，才匹配协商缓存。</p><h3 id="新鲜度限值"><a href="#新鲜度限值" class="headerlink" title="新鲜度限值"></a>新鲜度限值</h3><p>&emsp;&emsp;HTTP通过缓存将服务器资源的副本保留一段时间，这段时间称为新鲜度限值。这在一段时间内请求相同资源不会再通过服务器。HTTP协议中Cache-Control 和 Expires可以用来设置新鲜度的限值。</p><h3 id="服务器再验证"><a href="#服务器再验证" class="headerlink" title="服务器再验证"></a>服务器再验证</h3><p>&emsp;&emsp;浏览器或代理缓存中缓存的资源过期了，并不意味着它和原始服务器上的资源有实际的差异，仅仅意味着到了要进行核对的时间了。这种情况被称为服务器再验证。</p><ul><li>如果资源发生变化，则需要取得新的资源，并在缓存中替换旧资源。</li><li>如果资源没有发生变化，缓存只需要获取新的响应头，和一个新的过期时间，对缓存中的资源过期时间进行更新即可。</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>&emsp;&emsp;强缓存主要通过Cache-Control和Expires设置。Cache-control是HTTP1.1响应头设置，Expires是HTTP1.0中的响应头设置。</p><p>&emsp;&emsp;当匹配强缓存时，会直接从缓存中获得资源，不再与服务端通信。返回HTTP状态码为200。</p><p><img src="/imgs/fromdiskcache.png" alt="from-disk-cache"></p><p>&emsp;&emsp;Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。</p><h5 id="Cache-Control和Expires"><a href="#Cache-Control和Expires" class="headerlink" title="Cache-Control和Expires"></a>Cache-Control和Expires</h5><p><img src="/imgs/cachecontrolexpires.png" alt="cache-control-expires"></p><p>&emsp;&emsp;Cache-Control设置的是相对时间，单位为s。Expires设置具体的过期时间（时间戳）。由于客户端与服务端的时间可能存在差异，导致Expires设置可能存在偏差。因此，优先考虑使用Cache-Control。</p><p>&emsp;&emsp;目前依然会设置Expires，目的是为了兼容http1.0。</p><h5 id="Cache-Control属性"><a href="#Cache-Control属性" class="headerlink" title="Cache-Control属性"></a>Cache-Control属性</h5><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">max-age</td><td style="text-align:left">单位s。设置缓存最大的有效期。在max-age时间段内，浏览器不会再向服务器发送请求</td></tr><tr><td style="text-align:left">s-maxage</td><td style="text-align:left">单位s。只在代理服务器中的public资源生效，优先级高于max-age。在s-maxage内，向代理浏览器请求缓存资源。</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">指定资源，既可以被浏览器缓存，也可以被代理服务器缓存</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">只能被浏览器缓存</td></tr><tr><td style="text-align:left">no-cache</td><td style="text-align:left">忽略浏览器缓存，匹配协商缓存：与服务器确认资源是否被更改过(依据if-None-Match和Etag)，在决定是否使用本地缓存</td></tr><tr><td style="text-align:left">no-store</td><td style="text-align:left">禁止任何缓存，重新向服务器发送请求，下载完整响应</td></tr></tbody></table><h5 id="后端设置"><a href="#后端设置" class="headerlink" title="后端设置"></a>后端设置</h5><ul><li>node.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=&apos; + 864000);</span><br></pre></td></tr></table></figure></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/imgs/etaglastmodified.png" alt="last-modified"><br><br><br>&emsp;&emsp;协商缓存需要向服务器验证缓存的有效性。</p><p>&emsp;&emsp;HTTP1.1推荐使用的验证方式是If-None-Match/Etag，在HTTP1.0中则使用If-Modified-Since/Last-Modified。</p><h5 id="Etag与if-None-Match"><a href="#Etag与if-None-Match" class="headerlink" title="Etag与if-None-Match"></a>Etag与if-None-Match</h5><p>&emsp;&emsp;ETag值通常由服务器端计算，并在响应客户端请求时将它返回给客户端，验证资源是否已经修改。</p><blockquote><p>Etag值计算</p></blockquote><ul><li>Apache</li></ul><p>&emsp;&emsp;默认通过FileEtag中FileEtag INode Mtime Size的配置自动生成ETag。</p><ul><li>Nginx</li></ul><p>&emsp;&emsp;默认以“文件最后修改时间16进制-文件长度16进制”设置Etag。</p><ul><li>Express</li></ul><p>&emsp;&emsp;<a href="https://expressjs.com/en/resources/middleware/serve-static.html" target="_blank" rel="noopener">serve-static</a>中间件配置</p><h5 id="if-Modified-Since与Last-Modified"><a href="#if-Modified-Since与Last-Modified" class="headerlink" title="if-Modified-Since与Last-Modified"></a>if-Modified-Since与Last-Modified</h5><p>&emsp;&emsp;if-Modified-Since与Last-Modified是HTTP1.0中用来验证资源是否过期的请求/响应头，这两个头部都是日期，验证过程与Etag类似。使用这两个头部来验证资源是否更新时，存在以下问题：</p><ul><li>有些文件被重写了，但内容没有更改。重写的文件的修改日期与if-Modified-Since不相同，会被当成新资源，导致不必要的重新请求。</li><li>if-Modified-Since只能那个检查到以秒为最小时间差检测文件的变化，当修改文件过快可能不能及时检测到文件的变化。</li><li>有些文档资源被修改了，但修改内容(比如注释)并不重要，不需要所有的缓存都更新</li></ul><h5 id="后端设置-1"><a href="#后端设置-1" class="headerlink" title="后端设置"></a>后端设置</h5><ul><li>node.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=&apos; + 864000);</span><br><span class="line">res.setHeader(&apos;Last-Modified&apos;, xxx);</span><br><span class="line">res.setHeader(&apos;ETag&apos;, xxx);</span><br></pre></td></tr></table></figure></li></ul><h3 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h3><p>&emsp;&emsp;当响应头中没有设置Etag或者if-Modified-Since，会根据Date和Last-Modified之间的时间差值的10%作为缓存周期。</p><h3 id="html中缓存控制"><a href="#html中缓存控制" class="headerlink" title="html中缓存控制"></a>html中缓存控制</h3><ul><li><p>使用Meta标签设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache, must-revalidate&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 2017 08:21:57 GMT&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>微信浏览器中避免html被缓存</p><p>&emsp;&emsp;通过设置不存在的manifest。根据HTML5 W3C规范，解析器下载manifest header 404/410时，缓存即失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=&quot;IGNORE.manifest&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache, must-revalidate&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;cache&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 2017 08:21:57 GMT&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>html：使用协商缓存</li><li>js/css/image：使用强缓存，文件名采用hash值形式</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者： &lt;a href=&quot;https://staven630.github.io/blog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://staven630.github.io/blog/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;所有缓存资源都仅仅针对GET请求，而对POST，DELETE，PUT这类行为操作通常不做任何缓存。&lt;/p&gt;
&lt;h1 id=&quot;缓存的作用&quot;&gt;&lt;a href=&quot;#缓存的作用&quot; class=&quot;headerlink&quot; title=&quot;缓存的作用&quot;&gt;&lt;/a&gt;缓存的作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;减小网络I/O,减小服务器压力&lt;/li&gt;
&lt;li&gt;加快页面访问速度&lt;/li&gt;
&lt;li&gt;减少宽带消耗
    
    </summary>
    
      <category term="浏览器" scheme="http://www.h5per.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器缓存" scheme="http://www.h5per.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>browser-cache</title>
    <link href="http://www.h5per.com/2019/11/19/browser-cache/"/>
    <id>http://www.h5per.com/2019/11/19/browser-cache/</id>
    <published>2019-11-19T07:54:40.000Z</published>
    <updated>2019-11-19T09:27:28.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h3><p><strong>分为强缓存和协商缓存</strong></p><p>1、浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器。</p><p>2、当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。</p><p><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。<br><a id="more"></a></p><h3 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><blockquote><p>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的</p></blockquote><p><img src="/imgs/1c173fc742434551ba368f9f8d491b00.jpeg" alt></p><p>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p><blockquote><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT</p></blockquote><h4 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires，如<br><img src="/imgs/f57675f0e9694cdb841ec4c5630963f8.jpeg" alt></p><p>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）</p><p>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行</p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新</p><blockquote><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000</p></blockquote><h4 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control，如：<br><img src="/imgs/ebe91852cd6f4d07a7952c1620f41f95.jpeg" alt></p><p>浏览器缓存原理总结<br>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来</p><p>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新</p><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p><p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，<strong>Cache-Control优先级高于Expires：</strong><br><img src="/imgs/1acb4ca26a7546baa76f1f9941a620d3.jpeg" alt></p><h3 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h3><blockquote><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p></blockquote><p>1、通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header</p><p>2、通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header</p><blockquote><p>比如在javaweb里面，我们可以使用代码设置强缓存 , 还可以通过java代码设置不启用强缓存</p></blockquote><p>nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索nginx 设置 expires cache-control或 apache 设置 expires cache-control 都能找到不少相关的文章。</p><p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</p><p>处理缓存带来的问题</p><p>1、直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题</p><p>2、使用浏览器的隐私模式开发</p><p>3、如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）<br><img src="/imgs/e5bbd00efad7485485c5218df454e1b5.jpeg" alt></p><p>4、在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题</p><p>5、如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例<br><img src="/imgs/2f881b9140f445e6bd50a3c5714e013b.jpeg" alt><br>浏览器缓存原理总结<br>6、如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数</p><p>7、还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题</p><p>8、如果你用的是grunt和gulp、webpack这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存<br><img src="/imgs/2687a442342a4db2806c4fdc34ab1944.jpeg" alt></p><h3 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h3><blockquote><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年<br><img src="/imgs/1acb4ca26a7546baa76f1f9941a620d3.jpeg" alt></p></blockquote><blockquote><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p></blockquote><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576" target="_blank" rel="noopener">http://www.zhihu.com/question/20790576</a></p><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：</p><p><a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="noopener">http://fis.baidu.com/fis3/api/index.html</a></p><p><a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="noopener">http://ecomfe.github.io/edp/doc/initialization/install/</a></p><p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p><h3 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的<br><img src="/imgs/2a014b7d56d84785b8fe2c3c289f83b2.jpeg" alt></p><p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源<br><img src="/imgs/9f8b9be06b0c431ba94d6fa50b52cfd8.jpeg" alt></p><h4 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间<br><img src="/imgs/7c6ae8be4edc412a9310a8e2ea1928dc.jpeg" alt></p><p>2、浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值</p><p><img src="/imgs/7654619ffd684d72b705eb63ccacf8d2.jpeg" alt><br>3、服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header</p><p><img src="/imgs/cfab83dc06204ee18dbe4d06754f7271.jpeg" alt><br>4、浏览器收到304的响应后，就会从缓存中加载资源</p><p>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</p><blockquote><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是</p></blockquote><h4 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题</p><p><img src="/imgs/769330fec71b4cbc82b920ddbc2bbd7e.jpeg" alt><br>2、浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值</p><p><img src="/imgs/e7877671bb424bf6ad9b9a6b272b7fdd.jpeg" alt><br>3、服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><p><img src="/imgs/2cd34ef75026466d84ec97ea45b579a0.jpeg" alt><br>4、浏览器收到304的响应后，就会从缓存中加载资源。</p><h3 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h3><blockquote><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:</p></blockquote><p><img src="/imgs/5cd7d2bd425947dab08c373472ab91e4.jpeg" alt></p><blockquote><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p></blockquote><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。</p><p>有一种场景需要注意</p><p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p><p><strong>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</strong><br>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：<br><img src="/imgs/7296a1cb3128458894fc1a82c1b8f02b.jpeg" alt></p><blockquote><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义</p></blockquote><h3 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h3><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p><p>1、当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p><p>2、当f5刷新网页时，跳过强缓存，但是会检查协商缓存</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;a href=&quot;#一、浏览器缓存基本认识&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;/a&gt;一、浏览器缓存基本认识&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;分为强缓存和协商缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器。&lt;/p&gt;
&lt;p&gt;2、当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强缓存与协商缓存的共同点是&lt;/strong&gt;：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。&lt;/p&gt;
&lt;p&gt;当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。&lt;br&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://www.h5per.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器缓存" scheme="http://www.h5per.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>角度转方向</title>
    <link href="http://www.h5per.com/2019/05/16/angle-to-direction/"/>
    <id>http://www.h5per.com/2019/05/16/angle-to-direction/</id>
    <published>2019-05-16T13:59:43.000Z</published>
    <updated>2020-05-16T14:00:06.116Z</updated>
    
    <content type="html"><![CDATA[<p>今天开发遇到一个角度转方位的问题。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install angle-transform-direction --save</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tans = <span class="built_in">require</span>(<span class="string">'angle-to-direction'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tans.degree(<span class="number">50</span>)); <span class="comment">// "North East"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.degreeAbbr(<span class="number">50</span>)); <span class="comment">// "NE"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.degreeCn(<span class="number">50</span>)); <span class="comment">// "东北"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(tans.radian(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "North East"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.radianAbbr(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "NE"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.radianCn(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "东北"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开发遇到一个角度转方位的问题。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装:&quot;&gt;&lt;/a&gt;安装:&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cross-env使用笔记</title>
    <link href="http://www.h5per.com/2019/05/16/cross-env/"/>
    <id>http://www.h5per.com/2019/05/16/cross-env/</id>
    <published>2019-05-16T13:57:02.000Z</published>
    <updated>2019-11-01T05:14:17.522Z</updated>
    
    <content type="html"><![CDATA[<p>今天新来个前端同事，用的是 window 系统，环境始终不能跑起来。baidu 后知道了 cross-env 这个东西，直接 install 搞定。 </p><p>cross-env 能跨平台地设置及使用环境变量</p><p>大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）</p><a id="more"></a><p>cross-env让这一切变得简单，不同平台使用唯一指令，无需担心跨平台问题</p><h3 id="npm安装方式"><a href="#npm安装方式" class="headerlink" title="npm安装方式"></a>npm安装方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev cross-env</span><br></pre></td></tr></table></figure><h3 id="package-json-的配置"><a href="#package-json-的配置" class="headerlink" title="package.json 的配置"></a>package.json 的配置</h3><p>在<code>npm</code>脚本(多是package.json)里这么配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>，这样<code>NODE_ENV</code>便设置成功，无需担心跨平台问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天新来个前端同事，用的是 window 系统，环境始终不能跑起来。baidu 后知道了 cross-env 这个东西，直接 install 搞定。 &lt;/p&gt;
&lt;p&gt;cross-env 能跨平台地设置及使用环境变量&lt;/p&gt;
&lt;p&gt;大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="cross" scheme="http://www.h5per.com/tags/cross/"/>
    
      <category term="NODE_ENV" scheme="http://www.h5per.com/tags/NODE-ENV/"/>
    
  </entry>
  
  <entry>
    <title>js中null和undefined区别</title>
    <link href="http://www.h5per.com/2019/05/14/null-and-undefied/"/>
    <id>http://www.h5per.com/2019/05/14/null-and-undefied/</id>
    <published>2019-05-13T17:03:23.000Z</published>
    <updated>2019-11-01T05:14:17.523Z</updated>
    
    <content type="html"><![CDATA[<p><code>Undefined</code> 和 <code>Null</code> 是 Javascript 中两种特殊的原始数据类型(<code>Primary Type</code>)，它们都只有一个值，分别对应 <code>undefined</code> 和 <code>null</code> ，这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为：<br><a id="more"></a></p><h2 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h2><p>《<a href="http://speakingjs.com/" target="_blank" rel="noopener">Speaking JavaScript</a>》中阐述的由来。<br>原来，这与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>根据C语言的传统，null被设计成可以自动转为0。</p><p>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><code>null</code> 表示一个值被定义了，定义为“空值”</p><p>典型用法： </p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li><li>获取一个不存在<code>dom</code>节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'notExistElement'</span>)</span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li><li>使用 void 对表达式求值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="number">0</span> ; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="literal">false</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> []; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="literal">null</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125; ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined-运算"><a href="#null-和-undefined-运算" class="headerlink" title="null 和 undefined 运算"></a>null 和 undefined 运算</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>：”object” </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> ： “<span class="literal">undefined</span>”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="literal">true</span> </span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="literal">false</span> ：值相同，但类型不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//均可以用null或者undefined清空属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>; <span class="comment">// 值为 null(空), 但类型为对象 </span></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">undefined</span>; <span class="comment">// 值为 undefined, 类型为 undefined</span></span><br></pre></td></tr></table></figure><h2 id="延伸——垃圾回收站"><a href="#延伸——垃圾回收站" class="headerlink" title="延伸——垃圾回收站"></a>延伸——垃圾回收站</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emps = [<span class="string">'ss'</span>,<span class="string">'nn'</span>];</span><br><span class="line">emps = <span class="literal">null</span>;     <span class="comment">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure><p>参考链接<br><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a><br><a href="https://www.cnblogs.com/onepixel/p/7337248.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7337248.html</a><br><a href="http://bbs.itheima.com/thread-452694-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-452694-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Undefined&lt;/code&gt; 和 &lt;code&gt;Null&lt;/code&gt; 是 Javascript 中两种特殊的原始数据类型(&lt;code&gt;Primary Type&lt;/code&gt;)，它们都只有一个值，分别对应 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; ，这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为：&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.h5per.com/tags/js/"/>
    
      <category term="null" scheme="http://www.h5per.com/tags/null/"/>
    
      <category term="undefined" scheme="http://www.h5per.com/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://www.h5per.com/2019/05/14/http-status-code/"/>
    <id>http://www.h5per.com/2019/05/14/http-status-code/</id>
    <published>2019-05-13T17:02:42.000Z</published>
    <updated>2019-11-01T05:14:17.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP状态码（中文说明）"><a href="#HTTP状态码（中文说明）" class="headerlink" title="HTTP状态码（中文说明）"></a>HTTP状态码（中文说明）</h2><h3 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h3><p>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。<br><a id="more"></a></p><h3 id="2xx-（成功）-表示成功处理了请求的状态代码。"><a href="#2xx-（成功）-表示成功处理了请求的状态代码。" class="headerlink" title="2xx （成功） 表示成功处理了请求的状态代码。"></a>2xx （成功） 表示成功处理了请求的状态代码。</h3><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p><h3 id="3xx-（重定向）-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3xx-（重定向）-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h3><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><h3 id="4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。</h3><p>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><h3 id="5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h3><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><h2 id="HTTP状态码（英文说明）"><a href="#HTTP状态码（英文说明）" class="headerlink" title="HTTP状态码（英文说明）"></a>HTTP状态码（英文说明）</h2><h3 id="1xx-Informational"><a href="#1xx-Informational" class="headerlink" title="1xx Informational"></a>1xx Informational</h3><p>100 Continue<br>101 Switching Protocols<br>102 Processing (WebDAV)</p><h3 id="2xx-Success"><a href="#2xx-Success" class="headerlink" title="2xx Success"></a>2xx Success</h3><p>200 OK<br>201 Created<br>202 Accepted<br>203 Non-Authoritative Information<br>204 No Content<br>205 Reset Content<br>206 Partial Content<br>207 Multi-Status (WebDAV)<br>208 Already Reported (WebDAV)<br>226 IM Used</p><h3 id="3xx-Redirection"><a href="#3xx-Redirection" class="headerlink" title="3xx Redirection"></a>3xx Redirection</h3><p>300 Multiple Choices<br>301 Moved Permanently<br>302 Found<br>303 See Other<br>304 Not Modified<br>305 Use Proxy<br>306 (Unused)<br>307 Temporary Redirect<br>308 Permanent Redirect (experimental)</p><h3 id="4xx-Client-Error"><a href="#4xx-Client-Error" class="headerlink" title="4xx Client Error"></a>4xx Client Error</h3><p>401 Unauthorized<br>402 Payment Required<br>403 Forbidden<br>404 (Not Found) can be used instead.<br>405 Method Not Allowed<br>406 Not Acceptable<br>407 Proxy Authentication Required<br>408 Request Timeout<br>409 Conflict<br>410 Gone<br>411 Length Required<br>412 Precondition Failed<br>413 Request Entity Too Large<br>414 Request-URI Too Long<br>415 Unsupported Media Type<br>416 Requested Range Not Satisfiable<br>417 Expectation Failed<br>418 I’m a teapot (RFC 2324)<br>420 Enhance Your Calm (Twitter)<br>422 Unprocessable Entity (WebDAV)<br>423 Locked (WebDAV)<br>424 Failed Dependency (WebDAV)<br>425 Reserved for WebDAV<br>426 Upgrade Required<br>428 Precondition Required<br>429 Too Many Requests<br>431 Request Header Fields Too Large<br>444 No Response (Nginx)<br>449 Retry With (Microsoft)<br>450 Blocked by Windows Parental Controls (Microsoft)<br>451 Unavailable For Legal Reasons<br>499 Client Closed Request (Nginx)</p><h3 id="5xx-Server-Error"><a href="#5xx-Server-Error" class="headerlink" title="5xx Server Error"></a>5xx Server Error</h3><p>500 Internal Server Error<br>501 Not Implemented<br>502 Bad Gateway<br>503 Service Unavailable<br>504 Gateway Timeout<br>505 HTTP Version Not Supported<br>506 Variant Also Negotiates (Experimental)<br>507 Insufficient Storage (WebDAV)<br>508 Loop Detected (WebDAV)<br>509 Bandwidth Limit Exceeded (Apache)<br>510 Not Extended<br>511 Network Authentication Required<br>599 Network connect timeout error</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.restapitutorial.com/httpstatuscodes.html" target="_blank" rel="noopener">https://www.restapitutorial.com/httpstatuscodes.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP状态码（中文说明）&quot;&gt;&lt;a href=&quot;#HTTP状态码（中文说明）&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码（中文说明）&quot;&gt;&lt;/a&gt;HTTP状态码（中文说明）&lt;/h2&gt;&lt;h3 id=&quot;1xx（临时响应）&quot;&gt;&lt;a href=&quot;#1xx（临时响应）&quot; class=&quot;headerlink&quot; title=&quot;1xx（临时响应）&quot;&gt;&lt;/a&gt;1xx（临时响应）&lt;/h3&gt;&lt;p&gt;100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。&lt;br&gt;101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。&lt;br&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://www.h5per.com/tags/http/"/>
    
      <category term="状态码" scheme="http://www.h5per.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
</feed>
