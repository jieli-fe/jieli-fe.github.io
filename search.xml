<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js 事件</title>
      <link href="/2020/05/25/js-event/"/>
      <url>/2020/05/25/js-event/</url>
      
        <content type="html"><![CDATA[<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流描述的是从页面中接收事件的顺序。 事件流可分为两类： </p><ol><li>事件冒泡流</li><li>事件捕获流<a id="more"></a>在dom2级事件中规定，事件流分为三个阶段： 事件的捕获阶段、事件目标阶段、事件冒泡阶段。</li></ol><p><img src="/imgs/1843694-20191123211417957-337076825.png" alt></p><h3 id="事件的处理程序"><a href="#事件的处理程序" class="headerlink" title="事件的处理程序"></a>事件的处理程序</h3><p>事件处理程序可以分为三类：</p><ol><li>html事件</li><li>属性事件（dom0级事件）</li><li>事件监听回调（dom2级事件）</li></ol><h4 id="html事件"><a href="#html事件" class="headerlink" title="html事件"></a>html事件</h4><p>绑定方式：  on+’事件名称’=’执行函数’<br>html属性名称不区分大小写。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//html 事件绑定</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html事件的注意事项： </p><ol><li><p>html事件绑定的是个函数， 书写函数的时候注意特殊符号(<code>&quot;&quot;</code> <code>&lt;&gt;</code> <code>&#39;&#39;</code> <code>&amp;</code>)转义。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//转义引号</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert(&amp;quot;clicked&amp;quot;)"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML事件绑定的函数是<strong>全局作用域</strong>（异步加载js可能会报错）</p></li><li>this 指向事件目标元素</li><li><code>setAttribute</code> 方法修改</li><li>代码高耦合</li></ol><h4 id="属性事件"><a href="#属性事件" class="headerlink" title="属性事件"></a>属性事件</h4><p><code>onclick</code> 属性事件全部小写。<br>多次同时绑定一个属性事件， 只有最后定义的生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html 事件绑定</span></span><br><span class="line"><span class="keyword">var</span> btn = docuemnt.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line">btn = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="事件监听回调"><a href="#事件监听回调" class="headerlink" title="事件监听回调"></a>事件监听回调</h4><p>注意事项： </p><ul><li><code>addEventListener</code> 和 <code>removeEventListener</code> 必须是同一个引用</li><li><code>addEventListener</code> 可以绑定多次事件</li><li>事件流分为三个阶段，捕获、目标、冒泡阶段， 可以通过第三个参数控制哪个阶段绑定事件</li><li><code>this</code> 指向当前的元素</li><li>绑定事件不需要 加  <code>on</code></li><li>第三个参数是对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener MDN</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件监听</span></span><br><span class="line"><span class="keyword">var</span> hander = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = docuemnt.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.addEventListene(<span class="string">'click'</span>,hander, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>,hander, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全新Chrome Devtool Performance使用指南</title>
      <link href="/2020/05/23/Performance/"/>
      <url>/2020/05/23/Performance/</url>
      
        <content type="html"><![CDATA[<p>运行时性能表现（<code>runtime performance</code>）指的是当你的页面在浏览器运行时的性能表现，而不是在下载页面的时候的表现。这篇指南将会告诉你怎么用<code>Chrome DevToos Performance</code>功能去分析运行时性能表现。在<code>RAIL</code>性能评估模型下，你可以在这篇指南中可以学到怎么去用这个<code>performance</code>功能去分析<code>Response</code>, <code>Animation</code>, 以及 <code>Idle</code> 这三个性能指标。</p><p>让我们开始吧<br>在这篇指南中，我们会用Performance工具去分析一个现有的在线DEMO，然后教会你怎么去分析，从而找到性能瓶颈。</p><p>打开Chrome的匿名模式。匿名模式可以保证Chrome在一个相对干净的环境下运行。比如说，你安装了许多chrome插件，这些插件可能会影响我们分析性能表现。<br>在匿名模式下打开右边这个链接，<a href="https://googlechrome.github.io/devtools-samples/jank/" target="_blank" rel="noopener">DEMO</a>，这个网页就是我们要用来分析的DEMO。这个页面里都是很多上下移动的蓝色小方块。<br>按下Command+Opiton+I（Mac）或者Control+shift+I (Windows, Linux) 来打开Devtools<br><a id="more"></a><br><img src="/imgs/v2-92652c95d9ffcb3d13d24442d2583314_720w.jpg" alt></p><p>模拟移动设备的CPU<br>移动设备的CPU一般比台式机和笔记本弱很多。当你想分析页面的时候，可以用CPU控制器（CPU Throttling）来模拟移动端设备CPU。</p><p>在DevTools中，点击 Performance 的 tab。<br>确保 Screenshots checkbox 被选中<br>点击 Capture Settings（⚙️）按钮，DevTools会展示很多设置，来模拟各种状况<br>对于模拟CPU，选择2x slowdown，于是Devtools就开始模拟两倍低俗CPU</p><p><img src="/imgs/v2-6d2aa1e65c19c427c6ab19276419b79e_720w.jpg" alt></p><p>设置DEMO<br>为了使得这个DEMO有相对统一的运行表现（不同的读者，机器的性能千差万别）。这个DEMO提供了自定义功能，用来确保这个DEMO的统一表现。</p><p>一直点击 Add 10 这个按钮直到你能很明显看到蓝色小方块移动变慢，在性能比较好的机器上，大概要点击20次左右。<br>点击 Optimize按钮，你会发现蓝色小方块会变的很快而且动画变得平滑。<br>点击 un-optimize 按钮，蓝色小方块又会变成之前的模样。<br>记录运行时性能表现<br>在之前的DEMO中，当你运行优化模式的时候，蓝色小方块移动地非常快。为什么呢？明明两个模式都是移动了同样数量的小方块而且移动的时间也一样。那么现在我们在Performance界面下录制下发生的一切，并且学习如何分析这个记录，从而找到非优化模式下的性能瓶颈。</p><p>在DevTools中，点击 Record 。这时候Devtools就开始录制各种性能指标</p><p><img src="/imgs/v2-9f22b5385f17efd4341cbe25058cf35f_720w.jpg" alt></p><p>等待几分钟<br>点击Stop按钮，Devtools停止录制，处理数据，然后显示性能报告</p><p><img src="/imgs/v2-2fb06d74a5d8e54e0a947d616d3f68f8_720w.jpg" alt></p><p>wow，看起来有非常多的数据，别害怕，我们一个一个来介绍</p><p>分析报告<br>一旦你得到了页面的性能表现报告，那么就可以用它来分析页面的性能，从而找到性能瓶颈。</p><p>分析每一秒的帧<br>FPS（frames per second）是用来分析动画的一个主要性能指标。能保持在60的FPS的话，那么用户体验就是不错的。</p><p>观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。</p><p><img src="/imgs/v2-fd871e192ca970f82b13334c60d3bd7a_720w.jpg" alt></p><p>就在FPS图表下方，你会看到CPU图表。在CPU图表中的各种颜色与Summary面板里的颜色是相互对应的，Summary面板就在Performance面板的下方。CPU图表中的各种颜色代表着在这个时间段内，CPU在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。</p><p><img src="/imgs/v2-1cc581f23f53c6c83c2d1fbf68cfb15c_720w.jpg" alt></p><p>把鼠标移动到FPS，CPU或者NET图表之上，DevToos就会展示这个时间点界面的截图。左右移动鼠标，可以重发当时的屏幕录像。这被称为scrubbing, 他可以用来分析动画的各个细节。</p><p><img src="/imgs/v2-a95f54334770c724b75c21b7fe88a9d6_720w.jpg" alt></p><p>在Frames图表中，把鼠标移动到绿色条状图上，Devtools会展示这个帧的FPS。每个帧可能都在60以下，都没有达到60的标准。</p><p><img src="/imgs/v2-5e4f0fbcaca27f49ebb20c4fc16549e5_720w.jpg" alt></p><p>当然这个对于DEMO，可以相当容易观察到性能的问题。但是在现实使用场景下，就不是那么容易观察到了。所以要把常常使用这些工具来分析页面。</p><p>小功能：显示实时FPS面板</p><p>另外一个好用的小工具就是实时FPS面板，它可以实时展示页面的FPS指标</p><p>按下 Command+Shift+P（Mac）或者 Control+Shift+P(Windows, Linux) 打开命令菜单<br>输入Rendering，点选Show Rendering<br>在Rendering面板里，激活FPS Meter。FPS实时面板就出现在页面的右上方。</p><p><img src="/imgs/v2-8ed26d65f1d99968ba55b894e63eb914_720w.jpg" alt></p><p>关闭FPS Meter只要按下Escape就可以了。这篇指南里暂时用不上这个功能。<br>定位瓶颈<br>现在已经确定到这个页面的动画性能表现不太好，那么下一步就是找到为什么</p><p>注意Summary面板，你会发现CPU花费了大量的时间在rendering上。因为提高性能就是一门做减法的艺术，你的目标就是减少rendering的时间</p><p><img src="/imgs/v2-b93f1d9d060a369b2de3fd30fd6fc5d4_720w.jpg" alt></p><p>展开Main图表，Devtools展示了主线程运行状况。X轴代表着时间。每个长条代表着一个event。长条越长就代表这个event花费的时间越长。Y轴代表了调用栈（call stack）。在栈里，上面的event调用了下面的event。</p><p><img src="/imgs/v2-a010d11aa34123e41e9a6a26ea5d7b8b_720w.jpg" alt="1"></p><p>在性能报告中，有很多的数据。可以通过双击，拖动等等动作来放大缩小报告范围，从各种时间段来观察分析报告。</p><p><img src="/imgs/v2-3f18b42f1f7335958072d36641862afa_720w.jpg" alt></p><p>在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。<br>双击这个带有红色小三角的的事件。在Summary面板会看到详细信息。注意reveal这个链接，双击它会让高亮触发这个事件的event。如果点击了app.js:94这个链接，就会跳转到对应的代码处。</p><p><img src="/imgs/v2-ca44395a2fe6751356b3dc97a997b689_720w.jpg" alt></p><p>在app.update这个事件的长条下方，有很多被触发的紫色长条。如果放大这些事件长条，你会看到它们每个都带有红色小三角。点击其中一个紫色事件长条，Devtools在Summary面板里展示了更多关于这个事件的信息。确实，这里有很多reflow的警告。<br>在summary面板里点击app.js:70链接，Devtools会跳转到需要优化的代码处</p><p><img src="/imgs/v2-06ca9ac560ddd4c98eb20729e5d232c7_720w.jpg" alt></p><p>OK！<code>Devtools</code>里面还有很多很多指标需要你去探索，但是，对于怎么用<code>Devtools</code>去分析网页的运行时性能表现，你现在已经有了一个基本的概念。</p>]]></content>
      
      
      <categories>
          
          <category> chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
            <tag> chrome </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染过程和重绘(repaints)和重排(reflows)</title>
      <link href="/2020/05/23/repaint-reflows/"/>
      <url>/2020/05/23/repaint-reflows/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ol><li><p>浏览器解析<code>html</code>源码，然后创建一个 DOM树。<br>在<code>DOM</code>树中，每一个<code>HTML</code>标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。</p></li><li><p>浏览器解析<code>CSS</code>代码，计算出最终的样式数据。<br>对<code>CSS</code>代码中非法的语法她会直接忽略掉。<br>解析<code>CSS</code>的时候会按照如下顺序来定义优先级：浏览器默认设置，用户设置，外链样式，内联样式，html中的<code>style</code>。</p></li><li><p>构建出<code>DOM</code>树，并且计算出样式数据后，下一步就是构建一个 渲染树（<code>rendering tree</code>）。渲染树会忽略掉不需要渲染的元素，比如<code>head</code>、<code>display:none</code>的元素等。</p></li><li><p>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p><a id="more"></a></li></ol><p><img src="/imgs/5b543bda00015ce406240289.jpeg" alt="浏览器渲染过程"></p><h3 id="重绘和重排（repaints-and-reflows）"><a href="#重绘和重排（repaints-and-reflows）" class="headerlink" title="重绘和重排（repaints and reflows）"></a>重绘和重排（repaints and reflows）</h3><p><strong>重绘</strong>（<code>repaint</code>或<code>redraw</code>）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p><strong>触发重绘的条件</strong>：改变元素外观属性。如：<code>color</code>，<code>background-color</code>等。</p><p><strong>重排</strong>（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(<code>reflow</code>)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p><strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong><br>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</p><ol><li>页面渲染初始化；(无法避免)</li><li>添加或删除可见的DOM元素；</li><li>元素位置的改变，或者使用动画；</li><li>元素尺寸的改变——大小，外边距，边框；</li><li>浏览器窗口尺寸的变化（resize事件发生时）；</li><li>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</li><li>读取某些元素属性：（<code>offsetLeft/Top/Height/Width</code>,　<code>clientTop/Left/Width/Height</code>,　<code>scrollTop/Left/Width/Height</code>,　<code>width/height,　getComputedStyle()</code>,　<code>currentStyle(IE)</code>　)</li></ol><p><strong>重绘发生的情况：</strong><br>重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> repaint </tag>
            
            <tag> reflows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的new操作符的原理解析</title>
      <link href="/2020/05/19/js-new/"/>
      <url>/2020/05/19/js-new/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 中 <code>new</code> 操作符用于创建一个给定构造函数的对象实例。如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">// Person &#123;name: "Tom", age: 20&#125;</span></span><br></pre></td></tr></table></figure><p>我们定义了一个构造函数 <code>Person</code>，然后通过 <code>new</code> 操作符生成 <code>Person</code> 构造函数的一个实例并将其引用赋值给变量 <code>person1</code>。然后控制台打印出 <code>person1</code> 的内容，可以看到该实例对象具有 <code>name</code> 和 <code>age</code> 属性，它们的值就是我们在调用构造函数时传入的值。<br><a id="more"></a><br>那么，我们使用 <code>new</code> 操作符的时候都发生了哪些事呢？</p><p><code>new</code> 关键字进行的操作</p><p><code>new</code>关键字进行了如下的操作（为了便于描述，<code>obj</code> 用来表示创建的空对象、用 <code>constrc</code> 来表示构造函数）：</p><p>创建一个空对象 <code>obj（</code>{}）；<br>将 <code>obj</code> 的<code>[[prototype]]</code>属性指向构造函数 <code>constrc</code> 的原型（即 <code>obj.[[prototype]]</code> = <code>constrc.prototype</code>）。<br>将构造函数 <code>constrc</code> 内部的 <code>this</code> 绑定到新建的对象 <code>obj</code>，执行 <code>constrc</code>（也就是跟调用普通函数一样，只是此时函数的 this 为新创建的对象 <code>obj</code> 而已，就好像执行 <code>obj.constrc()</code>一样）；<br>若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象 <code>obj</code>（默认会添加 <code>return this</code>）。否则，返回引用类型的值。</p><p>这里补充说明一下：<code>[[prototype]]</code>属性是隐藏的，不过目前大部分新浏览器实现方式是使用<strong>proto</strong>来表示。构造函数的 <code>prototype</code> 属性我们是可以显式访问的。</p><p>让我们用图来展示文章开头的那个例子的过程：<br><img src="/imgs/20191119212535220.png" alt></p><p>从上面我们已经清楚地掌握了<code>new</code>的执行过程，那么我们就动手来自己实现一下<code>new</code>操作吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">fn,...arg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> result = fn.apply(obj,arg)</span><br><span class="line">  obj.__proto__ = fn.prototype</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用的例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = newFn(Person, <span class="string">'Tom'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1)  <span class="comment">// Person &#123;name: "Tom", age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> new操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端缓存机制</title>
      <link href="/2019/11/21/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/21/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>作者： <a href="https://staven630.github.io/blog/" target="_blank" rel="noopener">https://staven630.github.io/blog/</a></p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>&emsp;&emsp;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p><p>&emsp;&emsp;所有缓存资源都仅仅针对GET请求，而对POST，DELETE，PUT这类行为操作通常不做任何缓存。</p><h1 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h1><ul><li>减小网络I/O,减小服务器压力</li><li>加快页面访问速度</li><li>减少宽带消耗<a id="more"></a><h1 id="浏览器静态资源请求流程"><a href="#浏览器静态资源请求流程" class="headerlink" title="浏览器静态资源请求流程"></a>浏览器静态资源请求流程</h1><img src="/imgs/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f32352f63393134383063383130336161613339666537643030306363386633616135393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d657.webp" alt="浏览器静态资源请求流程"></li></ul><h1 id="资源缓存分类"><a href="#资源缓存分类" class="headerlink" title="资源缓存分类"></a>资源缓存分类</h1><p>&emsp;&emsp;按照获取资源时请求的优先级依次排序：</p><ul><li>Memory Cache、Disk Cache</li><li>Service Worker Cache</li><li>HTTP Cache</li><li>Push Cache</li></ul><h1 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP-Cache"></a>HTTP-Cache</h1><p>&emsp;&emsp;HTTP缓存又分为强缓存与协商缓存。强缓存优先级高于协商缓存。在匹配强缓存失败后，才匹配协商缓存。</p><h3 id="新鲜度限值"><a href="#新鲜度限值" class="headerlink" title="新鲜度限值"></a>新鲜度限值</h3><p>&emsp;&emsp;HTTP通过缓存将服务器资源的副本保留一段时间，这段时间称为新鲜度限值。这在一段时间内请求相同资源不会再通过服务器。HTTP协议中Cache-Control 和 Expires可以用来设置新鲜度的限值。</p><h3 id="服务器再验证"><a href="#服务器再验证" class="headerlink" title="服务器再验证"></a>服务器再验证</h3><p>&emsp;&emsp;浏览器或代理缓存中缓存的资源过期了，并不意味着它和原始服务器上的资源有实际的差异，仅仅意味着到了要进行核对的时间了。这种情况被称为服务器再验证。</p><ul><li>如果资源发生变化，则需要取得新的资源，并在缓存中替换旧资源。</li><li>如果资源没有发生变化，缓存只需要获取新的响应头，和一个新的过期时间，对缓存中的资源过期时间进行更新即可。</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>&emsp;&emsp;强缓存主要通过Cache-Control和Expires设置。Cache-control是HTTP1.1响应头设置，Expires是HTTP1.0中的响应头设置。</p><p>&emsp;&emsp;当匹配强缓存时，会直接从缓存中获得资源，不再与服务端通信。返回HTTP状态码为200。</p><p><img src="/imgs/fromdiskcache.png" alt="from-disk-cache"></p><p>&emsp;&emsp;Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。</p><h5 id="Cache-Control和Expires"><a href="#Cache-Control和Expires" class="headerlink" title="Cache-Control和Expires"></a>Cache-Control和Expires</h5><p><img src="/imgs/cachecontrolexpires.png" alt="cache-control-expires"></p><p>&emsp;&emsp;Cache-Control设置的是相对时间，单位为s。Expires设置具体的过期时间（时间戳）。由于客户端与服务端的时间可能存在差异，导致Expires设置可能存在偏差。因此，优先考虑使用Cache-Control。</p><p>&emsp;&emsp;目前依然会设置Expires，目的是为了兼容http1.0。</p><h5 id="Cache-Control属性"><a href="#Cache-Control属性" class="headerlink" title="Cache-Control属性"></a>Cache-Control属性</h5><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">max-age</td><td style="text-align:left">单位s。设置缓存最大的有效期。在max-age时间段内，浏览器不会再向服务器发送请求</td></tr><tr><td style="text-align:left">s-maxage</td><td style="text-align:left">单位s。只在代理服务器中的public资源生效，优先级高于max-age。在s-maxage内，向代理浏览器请求缓存资源。</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">指定资源，既可以被浏览器缓存，也可以被代理服务器缓存</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">只能被浏览器缓存</td></tr><tr><td style="text-align:left">no-cache</td><td style="text-align:left">忽略浏览器缓存，匹配协商缓存：与服务器确认资源是否被更改过(依据if-None-Match和Etag)，在决定是否使用本地缓存</td></tr><tr><td style="text-align:left">no-store</td><td style="text-align:left">禁止任何缓存，重新向服务器发送请求，下载完整响应</td></tr></tbody></table><h5 id="后端设置"><a href="#后端设置" class="headerlink" title="后端设置"></a>后端设置</h5><ul><li>node.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=&apos; + 864000);</span><br></pre></td></tr></table></figure></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/imgs/etaglastmodified.png" alt="last-modified"><br><br><br>&emsp;&emsp;协商缓存需要向服务器验证缓存的有效性。</p><p>&emsp;&emsp;HTTP1.1推荐使用的验证方式是If-None-Match/Etag，在HTTP1.0中则使用If-Modified-Since/Last-Modified。</p><h5 id="Etag与if-None-Match"><a href="#Etag与if-None-Match" class="headerlink" title="Etag与if-None-Match"></a>Etag与if-None-Match</h5><p>&emsp;&emsp;ETag值通常由服务器端计算，并在响应客户端请求时将它返回给客户端，验证资源是否已经修改。</p><blockquote><p>Etag值计算</p></blockquote><ul><li>Apache</li></ul><p>&emsp;&emsp;默认通过FileEtag中FileEtag INode Mtime Size的配置自动生成ETag。</p><ul><li>Nginx</li></ul><p>&emsp;&emsp;默认以“文件最后修改时间16进制-文件长度16进制”设置Etag。</p><ul><li>Express</li></ul><p>&emsp;&emsp;<a href="https://expressjs.com/en/resources/middleware/serve-static.html" target="_blank" rel="noopener">serve-static</a>中间件配置</p><h5 id="if-Modified-Since与Last-Modified"><a href="#if-Modified-Since与Last-Modified" class="headerlink" title="if-Modified-Since与Last-Modified"></a>if-Modified-Since与Last-Modified</h5><p>&emsp;&emsp;if-Modified-Since与Last-Modified是HTTP1.0中用来验证资源是否过期的请求/响应头，这两个头部都是日期，验证过程与Etag类似。使用这两个头部来验证资源是否更新时，存在以下问题：</p><ul><li>有些文件被重写了，但内容没有更改。重写的文件的修改日期与if-Modified-Since不相同，会被当成新资源，导致不必要的重新请求。</li><li>if-Modified-Since只能那个检查到以秒为最小时间差检测文件的变化，当修改文件过快可能不能及时检测到文件的变化。</li><li>有些文档资源被修改了，但修改内容(比如注释)并不重要，不需要所有的缓存都更新</li></ul><h5 id="后端设置-1"><a href="#后端设置-1" class="headerlink" title="后端设置"></a>后端设置</h5><ul><li>node.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=&apos; + 864000);</span><br><span class="line">res.setHeader(&apos;Last-Modified&apos;, xxx);</span><br><span class="line">res.setHeader(&apos;ETag&apos;, xxx);</span><br></pre></td></tr></table></figure></li></ul><h3 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h3><p>&emsp;&emsp;当响应头中没有设置Etag或者if-Modified-Since，会根据Date和Last-Modified之间的时间差值的10%作为缓存周期。</p><h3 id="html中缓存控制"><a href="#html中缓存控制" class="headerlink" title="html中缓存控制"></a>html中缓存控制</h3><ul><li><p>使用Meta标签设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache, must-revalidate&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 2017 08:21:57 GMT&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>微信浏览器中避免html被缓存</p><p>&emsp;&emsp;通过设置不存在的manifest。根据HTML5 W3C规范，解析器下载manifest header 404/410时，缓存即失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=&quot;IGNORE.manifest&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache, must-revalidate&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;cache&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 2017 08:21:57 GMT&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>html：使用协商缓存</li><li>js/css/image：使用强缓存，文件名采用hash值形式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser-cache</title>
      <link href="/2019/11/19/browser-cache/"/>
      <url>/2019/11/19/browser-cache/</url>
      
        <content type="html"><![CDATA[<h3 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h3><p><strong>分为强缓存和协商缓存</strong></p><p>1、浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器。</p><p>2、当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。</p><p><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。<br><a id="more"></a></p><h3 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><blockquote><p>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的</p></blockquote><p><img src="/imgs/1c173fc742434551ba368f9f8d491b00.jpeg" alt></p><p>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p><blockquote><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT</p></blockquote><h4 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires，如<br><img src="/imgs/f57675f0e9694cdb841ec4c5630963f8.jpeg" alt></p><p>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）</p><p>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行</p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新</p><blockquote><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000</p></blockquote><h4 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control，如：<br><img src="/imgs/ebe91852cd6f4d07a7952c1620f41f95.jpeg" alt></p><p>浏览器缓存原理总结<br>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来</p><p>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新</p><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p><p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，<strong>Cache-Control优先级高于Expires：</strong><br><img src="/imgs/1acb4ca26a7546baa76f1f9941a620d3.jpeg" alt></p><h3 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h3><blockquote><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p></blockquote><p>1、通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header</p><p>2、通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header</p><blockquote><p>比如在javaweb里面，我们可以使用代码设置强缓存 , 还可以通过java代码设置不启用强缓存</p></blockquote><p>nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索nginx 设置 expires cache-control或 apache 设置 expires cache-control 都能找到不少相关的文章。</p><p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</p><p>处理缓存带来的问题</p><p>1、直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题</p><p>2、使用浏览器的隐私模式开发</p><p>3、如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）<br><img src="/imgs/e5bbd00efad7485485c5218df454e1b5.jpeg" alt></p><p>4、在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题</p><p>5、如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例<br><img src="/imgs/2f881b9140f445e6bd50a3c5714e013b.jpeg" alt><br>浏览器缓存原理总结<br>6、如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数</p><p>7、还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题</p><p>8、如果你用的是grunt和gulp、webpack这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存<br><img src="/imgs/2687a442342a4db2806c4fdc34ab1944.jpeg" alt></p><h3 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h3><blockquote><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年<br><img src="/imgs/1acb4ca26a7546baa76f1f9941a620d3.jpeg" alt></p></blockquote><blockquote><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p></blockquote><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576" target="_blank" rel="noopener">http://www.zhihu.com/question/20790576</a></p><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：</p><p><a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="noopener">http://fis.baidu.com/fis3/api/index.html</a></p><p><a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="noopener">http://ecomfe.github.io/edp/doc/initialization/install/</a></p><p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p><h3 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的<br><img src="/imgs/2a014b7d56d84785b8fe2c3c289f83b2.jpeg" alt></p><p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源<br><img src="/imgs/9f8b9be06b0c431ba94d6fa50b52cfd8.jpeg" alt></p><h4 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间<br><img src="/imgs/7c6ae8be4edc412a9310a8e2ea1928dc.jpeg" alt></p><p>2、浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值</p><p><img src="/imgs/7654619ffd684d72b705eb63ccacf8d2.jpeg" alt><br>3、服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header</p><p><img src="/imgs/cfab83dc06204ee18dbe4d06754f7271.jpeg" alt><br>4、浏览器收到304的响应后，就会从缓存中加载资源</p><p>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</p><blockquote><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是</p></blockquote><h4 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题</p><p><img src="/imgs/769330fec71b4cbc82b920ddbc2bbd7e.jpeg" alt><br>2、浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值</p><p><img src="/imgs/e7877671bb424bf6ad9b9a6b272b7fdd.jpeg" alt><br>3、服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><p><img src="/imgs/2cd34ef75026466d84ec97ea45b579a0.jpeg" alt><br>4、浏览器收到304的响应后，就会从缓存中加载资源。</p><h3 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h3><blockquote><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:</p></blockquote><p><img src="/imgs/5cd7d2bd425947dab08c373472ab91e4.jpeg" alt></p><blockquote><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p></blockquote><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。</p><p>有一种场景需要注意</p><p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p><p><strong>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</strong><br>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：<br><img src="/imgs/7296a1cb3128458894fc1a82c1b8f02b.jpeg" alt></p><blockquote><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义</p></blockquote><h3 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h3><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p><p>1、当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p><p>2、当f5刷新网页时，跳过强缓存，但是会检查协商缓存</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>角度转方向</title>
      <link href="/2019/05/16/angle-to-direction/"/>
      <url>/2019/05/16/angle-to-direction/</url>
      
        <content type="html"><![CDATA[<p>今天开发遇到一个角度转方位的问题。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install angle-transform-direction --save</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tans = <span class="built_in">require</span>(<span class="string">'angle-to-direction'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tans.degree(<span class="number">50</span>)); <span class="comment">// "North East"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.degreeAbbr(<span class="number">50</span>)); <span class="comment">// "NE"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.degreeCn(<span class="number">50</span>)); <span class="comment">// "东北"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(tans.radian(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "North East"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.radianAbbr(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "NE"</span></span><br><span class="line"><span class="built_in">console</span>.log(tans.radianCn(<span class="number">50</span> / <span class="number">180</span> * <span class="built_in">Math</span>.PI)); <span class="comment">// "东北"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cross-env使用笔记</title>
      <link href="/2019/05/16/cross-env/"/>
      <url>/2019/05/16/cross-env/</url>
      
        <content type="html"><![CDATA[<p>今天新来个前端同事，用的是 window 系统，环境始终不能跑起来。baidu 后知道了 cross-env 这个东西，直接 install 搞定。 </p><p>cross-env 能跨平台地设置及使用环境变量</p><p>大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）</p><a id="more"></a><p>cross-env让这一切变得简单，不同平台使用唯一指令，无需担心跨平台问题</p><h3 id="npm安装方式"><a href="#npm安装方式" class="headerlink" title="npm安装方式"></a>npm安装方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev cross-env</span><br></pre></td></tr></table></figure><h3 id="package-json-的配置"><a href="#package-json-的配置" class="headerlink" title="package.json 的配置"></a>package.json 的配置</h3><p>在<code>npm</code>脚本(多是package.json)里这么配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>，这样<code>NODE_ENV</code>便设置成功，无需担心跨平台问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cross </tag>
            
            <tag> NODE_ENV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中null和undefined区别</title>
      <link href="/2019/05/14/null-and-undefied/"/>
      <url>/2019/05/14/null-and-undefied/</url>
      
        <content type="html"><![CDATA[<p><code>Undefined</code> 和 <code>Null</code> 是 Javascript 中两种特殊的原始数据类型(<code>Primary Type</code>)，它们都只有一个值，分别对应 <code>undefined</code> 和 <code>null</code> ，这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为：<br><a id="more"></a></p><h2 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h2><p>《<a href="http://speakingjs.com/" target="_blank" rel="noopener">Speaking JavaScript</a>》中阐述的由来。<br>原来，这与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>根据C语言的传统，null被设计成可以自动转为0。</p><p>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><code>null</code> 表示一个值被定义了，定义为“空值”</p><p>典型用法： </p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li><li>获取一个不存在<code>dom</code>节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'notExistElement'</span>)</span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li><li>使用 void 对表达式求值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="number">0</span> ; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="literal">false</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> []; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="literal">null</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125; ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined-运算"><a href="#null-和-undefined-运算" class="headerlink" title="null 和 undefined 运算"></a>null 和 undefined 运算</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>：”object” </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> ： “<span class="literal">undefined</span>”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="literal">true</span> </span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="literal">false</span> ：值相同，但类型不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//均可以用null或者undefined清空属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>; <span class="comment">// 值为 null(空), 但类型为对象 </span></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">undefined</span>; <span class="comment">// 值为 undefined, 类型为 undefined</span></span><br></pre></td></tr></table></figure><h2 id="延伸——垃圾回收站"><a href="#延伸——垃圾回收站" class="headerlink" title="延伸——垃圾回收站"></a>延伸——垃圾回收站</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emps = [<span class="string">'ss'</span>,<span class="string">'nn'</span>];</span><br><span class="line">emps = <span class="literal">null</span>;     <span class="comment">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure><p>参考链接<br><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a><br><a href="https://www.cnblogs.com/onepixel/p/7337248.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7337248.html</a><br><a href="http://bbs.itheima.com/thread-452694-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-452694-1-1.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> null </tag>
            
            <tag> undefined </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2019/05/14/http-status-code/"/>
      <url>/2019/05/14/http-status-code/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP状态码（中文说明）"><a href="#HTTP状态码（中文说明）" class="headerlink" title="HTTP状态码（中文说明）"></a>HTTP状态码（中文说明）</h2><h3 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h3><p>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。<br><a id="more"></a></p><h3 id="2xx-（成功）-表示成功处理了请求的状态代码。"><a href="#2xx-（成功）-表示成功处理了请求的状态代码。" class="headerlink" title="2xx （成功） 表示成功处理了请求的状态代码。"></a>2xx （成功） 表示成功处理了请求的状态代码。</h3><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p><h3 id="3xx-（重定向）-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3xx-（重定向）-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h3><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><h3 id="4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。</h3><p>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><h3 id="5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h3><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><h2 id="HTTP状态码（英文说明）"><a href="#HTTP状态码（英文说明）" class="headerlink" title="HTTP状态码（英文说明）"></a>HTTP状态码（英文说明）</h2><h3 id="1xx-Informational"><a href="#1xx-Informational" class="headerlink" title="1xx Informational"></a>1xx Informational</h3><p>100 Continue<br>101 Switching Protocols<br>102 Processing (WebDAV)</p><h3 id="2xx-Success"><a href="#2xx-Success" class="headerlink" title="2xx Success"></a>2xx Success</h3><p>200 OK<br>201 Created<br>202 Accepted<br>203 Non-Authoritative Information<br>204 No Content<br>205 Reset Content<br>206 Partial Content<br>207 Multi-Status (WebDAV)<br>208 Already Reported (WebDAV)<br>226 IM Used</p><h3 id="3xx-Redirection"><a href="#3xx-Redirection" class="headerlink" title="3xx Redirection"></a>3xx Redirection</h3><p>300 Multiple Choices<br>301 Moved Permanently<br>302 Found<br>303 See Other<br>304 Not Modified<br>305 Use Proxy<br>306 (Unused)<br>307 Temporary Redirect<br>308 Permanent Redirect (experimental)</p><h3 id="4xx-Client-Error"><a href="#4xx-Client-Error" class="headerlink" title="4xx Client Error"></a>4xx Client Error</h3><p>401 Unauthorized<br>402 Payment Required<br>403 Forbidden<br>404 (Not Found) can be used instead.<br>405 Method Not Allowed<br>406 Not Acceptable<br>407 Proxy Authentication Required<br>408 Request Timeout<br>409 Conflict<br>410 Gone<br>411 Length Required<br>412 Precondition Failed<br>413 Request Entity Too Large<br>414 Request-URI Too Long<br>415 Unsupported Media Type<br>416 Requested Range Not Satisfiable<br>417 Expectation Failed<br>418 I’m a teapot (RFC 2324)<br>420 Enhance Your Calm (Twitter)<br>422 Unprocessable Entity (WebDAV)<br>423 Locked (WebDAV)<br>424 Failed Dependency (WebDAV)<br>425 Reserved for WebDAV<br>426 Upgrade Required<br>428 Precondition Required<br>429 Too Many Requests<br>431 Request Header Fields Too Large<br>444 No Response (Nginx)<br>449 Retry With (Microsoft)<br>450 Blocked by Windows Parental Controls (Microsoft)<br>451 Unavailable For Legal Reasons<br>499 Client Closed Request (Nginx)</p><h3 id="5xx-Server-Error"><a href="#5xx-Server-Error" class="headerlink" title="5xx Server Error"></a>5xx Server Error</h3><p>500 Internal Server Error<br>501 Not Implemented<br>502 Bad Gateway<br>503 Service Unavailable<br>504 Gateway Timeout<br>505 HTTP Version Not Supported<br>506 Variant Also Negotiates (Experimental)<br>507 Insufficient Storage (WebDAV)<br>508 Loop Detected (WebDAV)<br>509 Bandwidth Limit Exceeded (Apache)<br>510 Not Extended<br>511 Network Authentication Required<br>599 Network connect timeout error</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.restapitutorial.com/httpstatuscodes.html" target="_blank" rel="noopener">https://www.restapitutorial.com/httpstatuscodes.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
